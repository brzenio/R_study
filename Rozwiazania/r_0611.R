# -*- coding: utf-8 -*-
"""R_0611

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1psPBFVqajtefrRW3bX1NS-8leuSb1At9

**We wszystkich ponizszych zadaniach stworz wlasne obiekty, tj. nazwane wektory, niepuste wektory i listy.**

Zadanie 1: Napisz funkcje, ktora oblicza liczbe a do potęgi b, niech b ma domyślną wartość 2.
"""

power <- function(x, y=2){
  return(x^y)
}

power(3)

"""Zadanie 2: Napisz funkcje, ktora zmienia wartość pi w globalnym środowisku R na dowolną wartość określoną jako argument."""

change_pi <- function(value){
  assign("pi", value, envir = .GlobalEnv)
}

rm(pi)
pi
change_pi(2)
pi

"""Zadanie 3: Napisz funkcję, ktara sprawdza, czy wartosci z pierwszego wektora znajduja się w zakresie między maksimum a minimum drugiego wektora."""

v1 <- c(1:10)
v2 <- c(5:20)

min <- min(v2)
max <- max(v2)

min
max

check <- function(v1, v2){
  v1[v1 >= min & v1 <= max]
}

check(v1,v2)

"""Zadanie 4: Napisz funkcje zliczajaca liczbe brakow danych w danym wektorze."""

v <- c(1,NaN, NaN, 2, 3)

IsNaN <- function(v){
  sum(is.na(v))
}

IsNaN(v)

"""Zadanie 5: Napisz funkcje konwertujaca wartosci w danym wektorze typu NA, NaN, INF, na jego wartosc srednia."""

v <- c(1,NaN, NaN, 2, 3)
m <- mean(v, na.rm = TRUE)
m

conv <- function(v){
  for(i in 1:length(v)){
    if(is.na(v[i]) | is.infinite(v[i] | is.nan(v[i]))){
    v[i] <- m
    }
  }
   return(v)
}

conv2 <- function(v) {
  v[is.na(v) | is.infinite(v)] <- mean(v, na.rm = TRUE)
  v
}


conv(v)
conv2(v)

"""Zadanie 6: Napisz funkcje, ktora wyswietli w konsoli informacje o liczbie elementow w danym wekotrze oraz w linijce ponizej informacje o typie wektora - prosze wykorzystac tylko raz funkcje do wyswietlania informacji."""

v <- c(1:10)

info <- function(v){
  cat("Length: ", length(v), "\n", "Type: ", typeof(v))
}

info(v)

"""Zadanie 7: Napisz funkcje wyznaczajaca wartosc srednia oraz mediane, pomijajac wartosci minimalna i maksymalna w danym wektorze. Funkcja nie powinna zwracac niczego oraz powinna wyswietlac w konsoli tresc typu "Srednia to: xxx, mediana to: xxx"
"""

v <- sample(1:100, 10, FALSE)
# v
# v <- sort(v)
# v

# mean(v)
# median(v)

# v1 <- c(v[3:length(v)-1])
# v1 

# v2 <- v
# v3 <- v2[c(-1,-length(v))]

# mean(v3)
# median(v3)


math_print <- function(v){
  v <- sort(v)
  v2 <- v[c(-1,-length(v))]
  cat("Srednia to:", mean(v2), ", mediana to:", median(v2))

}
# math_print(v)
# cat("Srednia to: ", mean, ", mediana to: ", median)



mean_median2 <- function(vec) {
  vec <- sort(vec)
  mean_val <- mean(vec[vec != min(vec) & vec != max(vec)], na.rm = TRUE)
  median_val <- median(vec[vec != min(vec) & vec != max(vec)], na.rm = TRUE)
  cat("Srednia to:", mean_val, ", mediana to:", median_val, "\n")
}

math_print(v)
cat("\n")
mean_median2(v)

"""Zadanie 8: Napisz funkcje, ktora wyznaczy dla danego wektora wejsciowego x, pewna statystyke opisowa np. srednia, min, max - owa statystyka powinna byc przekazana do fukcji jako prametr. Fukcja powinna wyswietlac w konsoli tresc "Wartosc [Nazwa przekazanej funkcji] to: xxx"."""

v <- sample(1:100, 10, FALSE)

stat <- function(v, stat_type){
  stat_calc <- stat_type(v)

  # można zamienić też na:
  # deparse(substitute(stat_type))
  # as.character(substitute(stat_type))
  cat("Wartosść", substitute(stat_type), "to:", stat_calc, "\n")
}

stat(v, mean)
stat(v, median)

"""Zadanie 9:

a) Stworz funkcje wskazujaca obserwacje odstajace z podanego wektora liczb rzeczywistych (x <-rcauchy(10)) wykorzystujaca regule kwartylow: Q1-1.5*(Q3-Q1) Q1+1.5*(Q3-Q1).

b) Funkcja powinna zwracac obiekt z podanymi atrybutami zawierajacymi informacje:
  a. jakie wartosci sa odstajace
  b. jakie wartosci sa nieodstajace
  c. indeksy wartosci odstajacych
  d. indeksy wartosci nieodstajacych

c) (wykorzystaj funkcje quantile, which, attr).
"""

v <- sample(1:100, 10, FALSE)

outliers <- function(v){
  Q1 <- quantile(v, 0.25)
  Q3 <- quantile(v, 0.75)

  roznica_q <- Q3 - Q1
  out <- v[v < (Q1 - 1.5 * roznica_q) | v > (Q3 + 1.5 * roznica_q)]
  non_out <- v[v >= (Q1 - 1.5 * roznica_q) & v <= (Q3 + 1.5 * roznica_q)]

  out_index <- which(v %in% out)
  non_out_index <- which(v %in% non_out)

  return(list(out = out, non_out = non_out, outl_index = out_index, non_out_index = non_out_index))
}


# outliers2 <- function(vec) {
#   Q1 <- quantile(vec, 0.25)
#   Q3 <- quantile(vec, 0.75)
#   IQR <- Q3 - Q1
#   outliers <- vec[vec < (Q1 - 1.5 * IQR) | vec > (Q3 + 1.5 * IQR)]
#   non_outliers <- vec[vec >= (Q1 - 1.5 * IQR) & vec <= (Q3 + 1.5 * IQR)]
#   outlier_indices <- which(vec %in% outliers)
#   non_outlier_indices <- which(vec %in% non_outliers)
#   return(list(outliers = outliers, non_outliers = non_outliers, outlier_indices = outlier_indices, non_outlier_indices = non_outlier_indices))
# }

outliers(v)
# outliers2(v)

"""Zadanie 10:

a) Stworz dwa wektory np. Nie_odstajace oraz Odstajace, ktore beda przechowywac wyniki zwracane przez funkcje stworzona w poprzednim kroku.
"""

# Wyżej jest już wynik

"""Zadanie 11:

a) Wysymuluj 30 liczb calkowitych z przedzialu od 10 do 20. Poczatkowa wartosc generatora liczb pseudolosowych powinna zostac ustalona na 444.

b) Stworz nastepnie poprzez prealokacje wektor liczb calkowitych o wartosciach domyslnych. 
   Dlugosc tego wektora ustalona jest jako dlugosc wysymulowanego wektora z punktu powyzej.

c) Za pomoca petli for wstaw nastepnie elementy wektora losowego (pkt. a) do wektora z pkt. b. 

   Petla powinna byc wykonana w dwoch wersjach: operujac na indeksach obydwu wektorow oraz na rzeczywistych wartosciach jednego z nich. W ostatnim kroku kazda petla powinna wyswietlac (nie uzywajac funckji print()) caly wektor (pkt. b) oraz informacje o jego typie (wiersz ponizej). 
"""

set.seed(444)

x <- sample(10:20, 30, replace = TRUE)
x

default <- integer(length(x))
default

for(i in 1:length(x)){
  default[i] <- x[i]
}

cat(default, "\n")
cat("Typ wektora:", typeof(default), "\n")

default2 <- integer(length(x))

for (el in x) {
  default2 <- c(default2, el)
}

cat(default2, "\n")
cat("Typ wektora:", typeof(default2), "\n")

"""Zadanie 12:

a) Stworz wektor zawierajacy liczby od 1 do 9,

b) Stworz liste o dlugosci odpowiadajacej dlugosci wektora z pkt. a.

c) Za pomoca petli for iterujacej w ramch wartosci zawartych w wektorze z pkt. a, wstaw w kolejne elementy listy podzbiór wektora z pkt a, tak aby
  pierwszy element listy zawieral pierwszy element, drugi element listy zawieral pierwszy oraz drugi element,..., 
  dziewiaty element listy zawieral wszystkie elementy. Stworzy sie swojego rodzaju piramida.
"""

v <- c(1:9)

lista <- vector(mode = "list", length(v))

for(i in v){
  lista[[i]] <- v[1:i]
}

lista

"""Zadanie 13:

a) Wykonaj powyzsze zadanie nie wykorzystujac petli.
"""

lista1 <- lapply(1:length(v), function(i) v[1:i])
lista1